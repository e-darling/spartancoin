"""
Unittest coins
"""

import random
from pathlib import Path
from typing import cast

import pytest
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ec

from spartancoin.transactions import decode_varint, DecodeError, encode_varint, Tx


@pytest.fixture(name="private_key")
def fixture_private_key() -> ec.EllipticCurvePrivateKey:
    """
    Return a repeatable private key for testing.

    Generated by `openssl ecparam -name secp256k1 -genkey -noout -out private.pem`
    or by `ec.generate_private_key(ec.SECP256K1())`.
    """
    with open(Path(__file__).parent / "private.pem", "rb") as f:
        return cast(
            ec.EllipticCurvePrivateKey,
            serialization.load_pem_private_key(f.read(), None),
        )


class TestVarInt:
    """Test variable-length encoded integers"""

    @staticmethod
    @pytest.mark.parametrize(
        "i, b",
        [
            (0, b"\x00"),
            (252, b"\xFC"),
            (253, b"\xFD\xFD\x00"),
            (255, b"\xFD\xFF\x00"),
            (0x3419, b"\xFD\x19\x34"),
            (0xDC4591, b"\xFE\x91\x45\xDC\x00"),
            (0x80081E5, b"\xFE\xE5\x81\x00\x08"),
            (0xB4DA564E2857, b"\xFFW(NV\xda\xb4\x00\x00"),
            (0x4BF583A17D59C158, b"\xFFX\xc1Y}\xa1\x83\xf5K"),
        ],
    )
    def test_encode_decode(i: int, b: bytes) -> None:
        """
        Test the encoding of variable-length integers.

        Test cases taken from https://wiki.bitcoinsv.io/index.php/VarInt
        """
        assert encode_varint(i) == b
        assert decode_varint(b) == i

    @staticmethod
    @pytest.mark.parametrize("i", [-5, -1, 2 ** 65])
    def test_encode_errors(i: int) -> None:
        """Test variable-length integers are unsigned and can fit in 9 bytes."""
        with pytest.raises(ValueError):
            encode_varint(i)

    @staticmethod
    @pytest.mark.parametrize(
        "b",
        [
            b"",
            b"\xFC-",
            b"\xFD\xFF",
            b"\xFD\x19\x34==",
            b"\xFFW(NV\xda\xb4\x00",
            b"\xFFX\xc1Y}\xa1\x83\xf5K=",
        ],
    )
    def test_decode_errors(b: bytes) -> None:
        """
        Invalid encodings should raise.
        """
        with pytest.raises(ValueError):
            decode_varint(b)


class TestTx:
    """Test the Tx class"""

    @staticmethod
    def test_genesis(private_key) -> None:
        """Test the Tx class"""
        coinbase = b"Genesis"
        prev_tx_hash = bytearray(32)
        prev_tx_hash[: len(coinbase)] = coinbase

        observed = Tx.from_prk(prev_tx_hash, -1, private_key).encode()

        assert observed[:32] == prev_tx_hash
        assert observed[32:36] == b"\xFF\xFF\xFF\xFF"

    @staticmethod
    def test_generic(private_key) -> None:
        """Test the Tx class"""
        tmp = b"not genesis"
        prev_tx_hash = bytearray(32)
        prev_tx_hash[: len(tmp)] = tmp

        observed = Tx.from_prk(prev_tx_hash, 1, private_key).encode()

        assert observed[:32] == prev_tx_hash
        assert observed[32:36] == b"\x01\x00\x00\x00"

    @staticmethod
    @pytest.mark.parametrize(
        "tx",
        [
            Tx(
                bytearray(random.randrange(1 << 8) for _ in range(32)),
                random.randrange(1 << 32),
                bytearray(
                    random.randrange(1 << 8) for _ in range(random.randrange(80))
                ),
                ec.generate_private_key(ec.SECP256K1()).public_key(),
            )
            for _ in range(10)
        ],
    )
    def test_encode_decode(tx) -> None:
        """Test encoding and decoding are inverses"""
        encoded = tx.encode()
        decoded = Tx.from_bytes(encoded)
        assert decoded == tx
